<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <title>OG Maze — Blockly + Phaser (Tile Coordinate Fix)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{--panel-w:360px}
    html,body{height:100%;margin:0;font-family:Inter,Arial,Helvetica,sans-serif}
    #app{display:flex;height:100vh;gap:8px;background:#111;padding:8px}
    #left{width:var(--panel-w);background:#f5f7fb;border-radius:8px;padding:8px;
          box-shadow:0 6px 18px rgba(0,0,0,0.4);overflow:hidden;display:flex;flex-direction:column}
    #blkHeader{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px}
    #blkHeader h2{margin:0;font-size:16px}
    #workspaceContainer{flex:1;border-radius:6px;overflow:hidden;background:white}
    #controls{display:flex;gap:6px;margin-top:8px}
    button{padding:8px 10px;border-radius:6px;border:0;cursor:pointer}
    button.run{background:#2b9cff;color:#fff}
    button.stop{background:#ff6b6b;color:#fff}
    button.reset{background:#ffd36b}
    button.clear{background:#9aa0ff;color:#fff}
    #right{flex:1;background:#222;border-radius:8px;display:flex;flex-direction:column;
           align-items:center;justify-content:center;padding:8px}
    #gameArea{width:960px;height:640px;border-radius:6px;overflow:hidden;background:#000;
              box-shadow:0 8px 30px rgba(0,0,0,0.6)}
    #info{color:#ddd;margin-top:8px;font-size:14px}
    .small{font-size:12px;color:#666;margin-top:6px}
    .blocklyDiv{height:100% !important; width:100% !important;}
  </style>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
</head>
<body>
  <div id="app">
    <div id="left">
      <div id="blkHeader">
        <h2>Editor Blok (Drag & Drop)</h2>
        <div>
          <button class="run" id="btnRun">Run ▶</button>
          <button class="stop" id="btnStop">Stop ■</button>
        </div>
      </div>

      <div id="workspaceContainer">
        <div id="blocklyDiv" style="height:520px; width:100%;"></div>
      </div>

      <div id="controls">
        <button class="reset" id="btnReset">Reset Character</button>
        <button class="clear" id="btnClear">Clear Logic</button>
      </div>

      <div class="small">Gunakan block <b>repeat n</b> untuk loop atau <b>if wall ahead</b> untuk percabangan :3.</div>
    </div>

    <div id="right">
      <div id="gameArea"></div>
    </div>
  </div>

  <script>
  /***** KONFIGURASI MAP DAN KOORDINAT *****/
  const TILE = 32;              // Ukuran tile 32px
  const MAP_W = 30;             // 30 kolom
  const MAP_H = 20;             // 20 baris
  const MAP_PIX_W = 960;
  const MAP_PIX_H = 640;

  // OG spawn di tile (1,5)
  const START = { r: 5, c: 1, dir: 1 };

  function tileToX(c){ return c * TILE + TILE / 2; }
  function tileToY(r){ return r * TILE + TILE / 2; }

  /***** BLOCKLY SETUP *****/
  const toolbox = `
  <xml xmlns="https://developers.google.com/blockly/xml" id="toolbox" style="display: none">
    <category name="Movement" colour="#4C97FF">
      <block type="move_block"></block>
      <block type="turn_left"></block>
      <block type="turn_right"></block>
    </category>
    <category name="Control" colour="#FFAB19">
      <block type="controls_repeat_ext">
        <value name="TIMES">
          <shadow type="math_number">
            <field name="NUM">3</field>
          </shadow>
        </value>
      </block>
      <block type="controls_if"></block>
    </category>
    <category name="Sensing" colour="#5CA65C">
      <block type="if_wall_ahead"></block>
    </category>
  </xml>`;

  const workspace = Blockly.inject('blocklyDiv', {
    toolbox: toolbox,
    scrollbars: true,
    zoom: { controls: true, wheel: true }
  });

  Blockly.defineBlocksWithJsonArray([
    { "type": "move_block", "message0": "move forward",
      "previousStatement": null, "nextStatement": null, "colour": 160 },
    { "type": "turn_left", "message0": "turn left",
      "previousStatement": null, "nextStatement": null, "colour": 230 },
    { "type": "turn_right", "message0": "turn right",
      "previousStatement": null, "nextStatement": null, "colour": 230 },
    { "type": "if_wall_ahead", "message0": "wall ahead?",
      "output": "Boolean", "colour": 65 }
  ]);

  Blockly.JavaScript['move_block'] = () => 'move();\n';
  Blockly.JavaScript['turn_left'] = () => 'turnLeft();\n';
  Blockly.JavaScript['turn_right'] = () => 'turnRight();\n';
  Blockly.JavaScript['if_wall_ahead'] = () => ['isWallAhead()', Blockly.JavaScript.ORDER_FUNCTION_CALL];

  /***** PHASER GAME *****/
  let ogState = { ...START };
  let gameScene;
  let commandQueue = [];
  let executing = false;
  let execInterval = 350;
  let execTimer = null;

  const game = new Phaser.Game({
    type: Phaser.AUTO,
    parent: 'gameArea',
    width: MAP_PIX_W,
    height: MAP_PIX_H,
    backgroundColor: '#000',
    scene: { preload, create },
    pixelArt: true
  });

  let ogSprite;
  function preload(){
    this.load.image('map', 'map_aksangfix.png');
    this.load.image('spawnfix', 'spawnfix.png');
    this.load.image('runright', 'runright.png');
    this.load.image('runup', 'runup.png');
  }

function create(){
  gameScene = this;

  // === MAP ===
  const map = this.add.image(0, 0, 'map').setOrigin(0, 0)
    .setDisplaySize(MAP_PIX_W, MAP_PIX_H);

  // === GRID DEBUG ===
  const g = this.add.graphics();
  g.lineStyle(1, 0x00ff00, 0.15);
  for (let i = 0; i <= MAP_W; i++) g.lineBetween(i*TILE, 0, i*TILE, MAP_H*TILE);
  for (let j = 0; j <= MAP_H; j++) g.lineBetween(0, j*TILE, MAP_W*TILE, j*TILE);

  // === OG ===
  const spawnX = tileToX(START.c) + 16;
  const spawnY = tileToY(START.r) + 8;
  ogSprite = this.add.image(spawnX, spawnY, 'spawnfix').setOrigin(0.5);
  ogSprite.setDisplaySize(TILE * 3, TILE * 3);

  this.highlight = this.add.rectangle(spawnX, spawnY, TILE, TILE)
    .setStrokeStyle(1, 0xffffff, 0.4)
    .setFillStyle(0xffffff, 0.05);

  updateOGVisual();

  // === MOUSE COORDINATE TRACKER ===
  const info = document.getElementById('info');
  this.input.on('pointermove', (pointer) => {
    const x = Math.floor(pointer.x);
    const y = Math.floor(pointer.y);

    // hitung tile koordinat
    const tileC = Math.floor(x / TILE);
    const tileR = Math.floor(y / TILE);

    info.innerHTML = `Mouse: (${x}, ${y}) | Tile: (r=${tileR}, c=${tileC})`;
  });

  // reset teks ketika mouse keluar
  this.input.on('pointerout', () => {
    info.innerHTML = 'OG Maze — gunakan blok untuk menggerakkan OG melalui map.';
  });
}


function updateOGVisual(){
  // ganti tekstur berdasarkan arah
  if(ogState.dir === 1) ogSprite.setTexture('runright');
  else if(ogState.dir === 0) ogSprite.setTexture('runup');
  else ogSprite.setTexture('runright');

  // rotasi arah
  if(ogState.dir === 3) ogSprite.angle = 180;
  else if(ogState.dir === 2) ogSprite.angle = 90;
  else ogSprite.angle = 0;

  // sinkronkan highlight
  if(gameScene && gameScene.highlight){
    gameScene.highlight.x = tileToX(ogState.c) + 16;
    gameScene.highlight.y = tileToY(ogState.r) + 8;
  }
}


  // === Logika blok ===
  function move(){ commandQueue.push({cmd:'MOVE'}); }
  function turnLeft(){ commandQueue.push({cmd:'TURN_LEFT'}); }
  function turnRight(){ commandQueue.push({cmd:'TURN_RIGHT'}); }
  function isWallAhead(){
    const next = peekNextTile(ogState.r, ogState.c, ogState.dir, 1);
    return next.r<0 || next.r>=MAP_H || next.c<0 || next.c>=MAP_W;
  }

  function peekNextTile(r,c,dir,steps){
    let dr=0,dc=0;
    if(dir===0) dr=-1; else if(dir===1) dc=1;
    else if(dir===2) dr=1; else if(dir===3) dc=-1;
    return {r:r+dr*steps, c:c+dc*steps};
  }

  function executeNextCommand(){
    if(commandQueue.length===0){ stopExecution(); return; }
    const item = commandQueue.shift();
    if(item.cmd==='MOVE'){ attemptMove(1); }
    else if(item.cmd==='TURN_LEFT'){ ogState.dir=(ogState.dir+3)%4; updateOGVisual(); }
    else if(item.cmd==='TURN_RIGHT'){ ogState.dir=(ogState.dir+1)%4; updateOGVisual(); }
  }

  function attemptMove(steps){
    const next = peekNextTile(ogState.r, ogState.c, ogState.dir, steps);
    if(next.r<0||next.r>=MAP_H||next.c<0||next.c>=MAP_W){
      stopExecution(); flashMessage('Blocked (boundary).'); return;
    }
    ogState.r = next.r; ogState.c = next.c;
    const targetX = tileToX(ogState.c), targetY = tileToY(ogState.r);
    gameScene.tweens.add({
      targets: ogSprite, x:targetX, y:targetY,
      duration: execInterval-80, ease:'Linear', onComplete: updateOGVisual
    });
    gameScene.highlight.x = targetX;
    gameScene.highlight.y = targetY;
  }

  function runQueue(){
    if(executing) return;
    executing = true;
    execTimer = setInterval(()=>{
      if(commandQueue.length===0){ stopExecution(); return; }
      executeNextCommand();
    }, execInterval);
  }

  function stopExecution(){
    executing=false;
    if(execTimer){ clearInterval(execTimer); execTimer=null; }
  }

  function flushQueue(){ commandQueue=[]; stopExecution(); }

  function resetOG(){
    flushQueue();
    ogState = {...START};
    if(ogSprite){
      ogSprite.x = tileToX(ogState.c);
      ogSprite.y = tileToY(ogState.r);
      ogSprite.angle = 0;
      updateOGVisual();
    }
  }

  function flashMessage(msg){
    const info = document.getElementById('info');
    info.textContent = msg;
    setTimeout(()=>{ info.textContent='OG Maze — gunakan blok untuk menggerakkan OG melalui map.' },1800);
  }

  /***** BUTTONS *****/
  document.getElementById('btnRun').onclick = ()=>{
    flushQueue();
    try{
      const code = Blockly.JavaScript.workspaceToCode(workspace);
      const wrapped = new Function('move','turnLeft','turnRight','isWallAhead', code);
      wrapped(move,turnLeft,turnRight,isWallAhead);
      if(commandQueue.length===0){ flashMessage('Program menghasilkan 0 perintah.'); }
      else runQueue();
    }catch(e){ flashMessage('Error: '+e.message); console.error(e); }
  };
  document.getElementById('btnStop').onclick = ()=>{ stopExecution(); flashMessage('Execution stopped.'); };
  document.getElementById('btnReset').onclick = ()=>{ resetOG(); flashMessage('OG reset.'); };
  document.getElementById('btnClear').onclick = ()=>{ workspace.clear(); flushQueue(); };
  </script>
</body>
</html>
